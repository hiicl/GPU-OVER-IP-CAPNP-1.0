// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: hook-launcher.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>
#if !CAPNP_LITE
#include <capnp/capability.h>
#endif  // !CAPNP_LITE

#ifndef CAPNP_VERSION
#error "CAPNP_VERSION is not defined, is capnp/generated-header-support.h missing?"
#elif CAPNP_VERSION != 1002000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include "common.capnp.h"

CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(ddb256ee5b6b53b3);
CAPNP_DECLARE_SCHEMA(eb7186a22c3fa0de);
CAPNP_DECLARE_SCHEMA(b5d15336d30e0dd1);
CAPNP_DECLARE_SCHEMA(a000d051b28a6d94);
CAPNP_DECLARE_SCHEMA(d9ccdb1e5a73a940);
CAPNP_DECLARE_SCHEMA(eb3523cbe98a804f);
CAPNP_DECLARE_SCHEMA(fa389ebe41e98f39);
CAPNP_DECLARE_SCHEMA(80b6bbac6ed09d85);
CAPNP_DECLARE_SCHEMA(e76522c9a2f40b20);
CAPNP_DECLARE_SCHEMA(befc738967da08f4);
CAPNP_DECLARE_SCHEMA(cbbd2a831eac2f20);
CAPNP_DECLARE_SCHEMA(a4ab519fa8915cb7);
CAPNP_DECLARE_SCHEMA(8cad8defaf95e7b0);
CAPNP_DECLARE_SCHEMA(bb47eae7bc02e6df);
CAPNP_DECLARE_SCHEMA(8164a155f1640357);
CAPNP_DECLARE_SCHEMA(e407a39af6852337);
CAPNP_DECLARE_SCHEMA(ac17d9ac7710bc97);
CAPNP_DECLARE_SCHEMA(dd45cfaa27648933);
CAPNP_DECLARE_SCHEMA(c08ebc98e790327d);
CAPNP_DECLARE_SCHEMA(8e06bfe25704b493);
CAPNP_DECLARE_SCHEMA(9067a75daac545ad);
CAPNP_DECLARE_SCHEMA(e512d381fed0aa2e);

}  // namespace schemas
}  // namespace capnp


struct MemcpyPlan {
  MemcpyPlan() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ddb256ee5b6b53b3, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct NodeStatus {
  NodeStatus() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(eb7186a22c3fa0de, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HookLauncher {
  HookLauncher() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct PlanMemcpyHtoDParams;
  struct PlanMemcpyHtoDResults;
  struct PlanMemcpyDtoHParams;
  struct PlanMemcpyDtoHResults;
  struct GetNodeStatusParams;
  struct GetNodeStatusResults;
  struct PrefetchDataParams;
  struct PrefetchDataResults;
  struct MeasureBandwidthParams;
  struct MeasureBandwidthResults;
  struct TrackAsyncTaskParams;
  struct TrackAsyncTaskResults;
  struct GetMemoryLocationParams;
  struct GetMemoryLocationResults;
  struct AdvisePrefetchParams;
  struct AdvisePrefetchResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(b5d15336d30e0dd1)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct HookLauncher::PlanMemcpyHtoDParams {
  PlanMemcpyHtoDParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a000d051b28a6d94, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HookLauncher::PlanMemcpyHtoDResults {
  PlanMemcpyHtoDResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d9ccdb1e5a73a940, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HookLauncher::PlanMemcpyDtoHParams {
  PlanMemcpyDtoHParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(eb3523cbe98a804f, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HookLauncher::PlanMemcpyDtoHResults {
  PlanMemcpyDtoHResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fa389ebe41e98f39, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HookLauncher::GetNodeStatusParams {
  GetNodeStatusParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(80b6bbac6ed09d85, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HookLauncher::GetNodeStatusResults {
  GetNodeStatusResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e76522c9a2f40b20, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HookLauncher::PrefetchDataParams {
  PrefetchDataParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(befc738967da08f4, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HookLauncher::PrefetchDataResults {
  PrefetchDataResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cbbd2a831eac2f20, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HookLauncher::MeasureBandwidthParams {
  MeasureBandwidthParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a4ab519fa8915cb7, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HookLauncher::MeasureBandwidthResults {
  MeasureBandwidthResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8cad8defaf95e7b0, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HookLauncher::TrackAsyncTaskParams {
  TrackAsyncTaskParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bb47eae7bc02e6df, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HookLauncher::TrackAsyncTaskResults {
  TrackAsyncTaskResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8164a155f1640357, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HookLauncher::GetMemoryLocationParams {
  GetMemoryLocationParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e407a39af6852337, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HookLauncher::GetMemoryLocationResults {
  GetMemoryLocationResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ac17d9ac7710bc97, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HookLauncher::AdvisePrefetchParams {
  AdvisePrefetchParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dd45cfaa27648933, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HookLauncher::AdvisePrefetchResults {
  AdvisePrefetchResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c08ebc98e790327d, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BandwidthResult {
  BandwidthResult() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8e06bfe25704b493, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TaskStatus {
  TaskStatus() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9067a75daac545ad, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct NodeInfo {
  NodeInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e512d381fed0aa2e, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class MemcpyPlan::Reader {
public:
  typedef MemcpyPlan Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTargetServerIp() const;
  inline  ::capnp::Text::Reader getTargetServerIp() const;

  inline  ::uint16_t getTargetServerZmqPort() const;

  inline  ::ErrorCode getError() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MemcpyPlan::Builder {
public:
  typedef MemcpyPlan Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTargetServerIp();
  inline  ::capnp::Text::Builder getTargetServerIp();
  inline void setTargetServerIp( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initTargetServerIp(unsigned int size);
  inline void adoptTargetServerIp(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownTargetServerIp();

  inline  ::uint16_t getTargetServerZmqPort();
  inline void setTargetServerZmqPort( ::uint16_t value);

  inline  ::ErrorCode getError();
  inline void setError( ::ErrorCode value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MemcpyPlan::Pipeline {
public:
  typedef MemcpyPlan Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class NodeStatus::Reader {
public:
  typedef NodeStatus Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasId() const;
  inline  ::capnp::Text::Reader getId() const;

  inline  ::uint64_t getAvailableMemory() const;

  inline float getGpuUtilization() const;

  inline float getNetworkLatency() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class NodeStatus::Builder {
public:
  typedef NodeStatus Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasId();
  inline  ::capnp::Text::Builder getId();
  inline void setId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initId(unsigned int size);
  inline void adoptId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownId();

  inline  ::uint64_t getAvailableMemory();
  inline void setAvailableMemory( ::uint64_t value);

  inline float getGpuUtilization();
  inline void setGpuUtilization(float value);

  inline float getNetworkLatency();
  inline void setNetworkLatency(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class NodeStatus::Pipeline {
public:
  typedef NodeStatus Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class HookLauncher::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef HookLauncher Calls;
  typedef HookLauncher Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::HookLauncher::PlanMemcpyHtoDParams,  ::HookLauncher::PlanMemcpyHtoDResults> planMemcpyHtoDRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::HookLauncher::PlanMemcpyDtoHParams,  ::HookLauncher::PlanMemcpyDtoHResults> planMemcpyDtoHRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::HookLauncher::GetNodeStatusParams,  ::HookLauncher::GetNodeStatusResults> getNodeStatusRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::HookLauncher::PrefetchDataParams,  ::HookLauncher::PrefetchDataResults> prefetchDataRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::HookLauncher::MeasureBandwidthParams,  ::HookLauncher::MeasureBandwidthResults> measureBandwidthRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::HookLauncher::TrackAsyncTaskParams,  ::HookLauncher::TrackAsyncTaskResults> trackAsyncTaskRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::HookLauncher::GetMemoryLocationParams,  ::HookLauncher::GetMemoryLocationResults> getMemoryLocationRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::HookLauncher::AdvisePrefetchParams,  ::HookLauncher::AdvisePrefetchResults> advisePrefetchRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class HookLauncher::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef HookLauncher Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::HookLauncher::PlanMemcpyHtoDParams PlanMemcpyHtoDParams;
  typedef  ::HookLauncher::PlanMemcpyHtoDResults PlanMemcpyHtoDResults;
  typedef ::capnp::CallContext<PlanMemcpyHtoDParams, PlanMemcpyHtoDResults> PlanMemcpyHtoDContext;
  virtual ::kj::Promise<void> planMemcpyHtoD(PlanMemcpyHtoDContext context);
  typedef  ::HookLauncher::PlanMemcpyDtoHParams PlanMemcpyDtoHParams;
  typedef  ::HookLauncher::PlanMemcpyDtoHResults PlanMemcpyDtoHResults;
  typedef ::capnp::CallContext<PlanMemcpyDtoHParams, PlanMemcpyDtoHResults> PlanMemcpyDtoHContext;
  virtual ::kj::Promise<void> planMemcpyDtoH(PlanMemcpyDtoHContext context);
  typedef  ::HookLauncher::GetNodeStatusParams GetNodeStatusParams;
  typedef  ::HookLauncher::GetNodeStatusResults GetNodeStatusResults;
  typedef ::capnp::CallContext<GetNodeStatusParams, GetNodeStatusResults> GetNodeStatusContext;
  virtual ::kj::Promise<void> getNodeStatus(GetNodeStatusContext context);
  typedef  ::HookLauncher::PrefetchDataParams PrefetchDataParams;
  typedef  ::HookLauncher::PrefetchDataResults PrefetchDataResults;
  typedef ::capnp::CallContext<PrefetchDataParams, PrefetchDataResults> PrefetchDataContext;
  virtual ::kj::Promise<void> prefetchData(PrefetchDataContext context);
  typedef  ::HookLauncher::MeasureBandwidthParams MeasureBandwidthParams;
  typedef  ::HookLauncher::MeasureBandwidthResults MeasureBandwidthResults;
  typedef ::capnp::CallContext<MeasureBandwidthParams, MeasureBandwidthResults> MeasureBandwidthContext;
  virtual ::kj::Promise<void> measureBandwidth(MeasureBandwidthContext context);
  typedef  ::HookLauncher::TrackAsyncTaskParams TrackAsyncTaskParams;
  typedef  ::HookLauncher::TrackAsyncTaskResults TrackAsyncTaskResults;
  typedef ::capnp::CallContext<TrackAsyncTaskParams, TrackAsyncTaskResults> TrackAsyncTaskContext;
  virtual ::kj::Promise<void> trackAsyncTask(TrackAsyncTaskContext context);
  typedef  ::HookLauncher::GetMemoryLocationParams GetMemoryLocationParams;
  typedef  ::HookLauncher::GetMemoryLocationResults GetMemoryLocationResults;
  typedef ::capnp::CallContext<GetMemoryLocationParams, GetMemoryLocationResults> GetMemoryLocationContext;
  virtual ::kj::Promise<void> getMemoryLocation(GetMemoryLocationContext context);
  typedef  ::HookLauncher::AdvisePrefetchParams AdvisePrefetchParams;
  typedef  ::HookLauncher::AdvisePrefetchResults AdvisePrefetchResults;
  typedef ::capnp::CallContext<AdvisePrefetchParams, AdvisePrefetchResults> AdvisePrefetchContext;
  virtual ::kj::Promise<void> advisePrefetch(AdvisePrefetchContext context);

  inline  ::HookLauncher::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::HookLauncher>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class HookLauncher::PlanMemcpyHtoDParams::Reader {
public:
  typedef PlanMemcpyHtoDParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasDstHandle() const;
  inline  ::MemoryHandle::Reader getDstHandle() const;

  inline  ::uint64_t getSize() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HookLauncher::PlanMemcpyHtoDParams::Builder {
public:
  typedef PlanMemcpyHtoDParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasDstHandle();
  inline  ::MemoryHandle::Builder getDstHandle();
  inline void setDstHandle( ::MemoryHandle::Reader value);
  inline  ::MemoryHandle::Builder initDstHandle();
  inline void adoptDstHandle(::capnp::Orphan< ::MemoryHandle>&& value);
  inline ::capnp::Orphan< ::MemoryHandle> disownDstHandle();

  inline  ::uint64_t getSize();
  inline void setSize( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HookLauncher::PlanMemcpyHtoDParams::Pipeline {
public:
  typedef PlanMemcpyHtoDParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::MemoryHandle::Pipeline getDstHandle();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class HookLauncher::PlanMemcpyHtoDResults::Reader {
public:
  typedef PlanMemcpyHtoDResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPlan() const;
  inline  ::MemcpyPlan::Reader getPlan() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HookLauncher::PlanMemcpyHtoDResults::Builder {
public:
  typedef PlanMemcpyHtoDResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPlan();
  inline  ::MemcpyPlan::Builder getPlan();
  inline void setPlan( ::MemcpyPlan::Reader value);
  inline  ::MemcpyPlan::Builder initPlan();
  inline void adoptPlan(::capnp::Orphan< ::MemcpyPlan>&& value);
  inline ::capnp::Orphan< ::MemcpyPlan> disownPlan();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HookLauncher::PlanMemcpyHtoDResults::Pipeline {
public:
  typedef PlanMemcpyHtoDResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::MemcpyPlan::Pipeline getPlan();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class HookLauncher::PlanMemcpyDtoHParams::Reader {
public:
  typedef PlanMemcpyDtoHParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasSrcHandle() const;
  inline  ::MemoryHandle::Reader getSrcHandle() const;

  inline  ::uint64_t getSize() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HookLauncher::PlanMemcpyDtoHParams::Builder {
public:
  typedef PlanMemcpyDtoHParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasSrcHandle();
  inline  ::MemoryHandle::Builder getSrcHandle();
  inline void setSrcHandle( ::MemoryHandle::Reader value);
  inline  ::MemoryHandle::Builder initSrcHandle();
  inline void adoptSrcHandle(::capnp::Orphan< ::MemoryHandle>&& value);
  inline ::capnp::Orphan< ::MemoryHandle> disownSrcHandle();

  inline  ::uint64_t getSize();
  inline void setSize( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HookLauncher::PlanMemcpyDtoHParams::Pipeline {
public:
  typedef PlanMemcpyDtoHParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::MemoryHandle::Pipeline getSrcHandle();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class HookLauncher::PlanMemcpyDtoHResults::Reader {
public:
  typedef PlanMemcpyDtoHResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPlan() const;
  inline  ::MemcpyPlan::Reader getPlan() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HookLauncher::PlanMemcpyDtoHResults::Builder {
public:
  typedef PlanMemcpyDtoHResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPlan();
  inline  ::MemcpyPlan::Builder getPlan();
  inline void setPlan( ::MemcpyPlan::Reader value);
  inline  ::MemcpyPlan::Builder initPlan();
  inline void adoptPlan(::capnp::Orphan< ::MemcpyPlan>&& value);
  inline ::capnp::Orphan< ::MemcpyPlan> disownPlan();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HookLauncher::PlanMemcpyDtoHResults::Pipeline {
public:
  typedef PlanMemcpyDtoHResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::MemcpyPlan::Pipeline getPlan();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class HookLauncher::GetNodeStatusParams::Reader {
public:
  typedef GetNodeStatusParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HookLauncher::GetNodeStatusParams::Builder {
public:
  typedef GetNodeStatusParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HookLauncher::GetNodeStatusParams::Pipeline {
public:
  typedef GetNodeStatusParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class HookLauncher::GetNodeStatusResults::Reader {
public:
  typedef GetNodeStatusResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasNodes() const;
  inline  ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>::Reader getNodes() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HookLauncher::GetNodeStatusResults::Builder {
public:
  typedef GetNodeStatusResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasNodes();
  inline  ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>::Builder getNodes();
  inline void setNodes( ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>::Builder initNodes(unsigned int size);
  inline void adoptNodes(::capnp::Orphan< ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>> disownNodes();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HookLauncher::GetNodeStatusResults::Pipeline {
public:
  typedef GetNodeStatusResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class HookLauncher::PrefetchDataParams::Reader {
public:
  typedef PrefetchDataParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHandle() const;
  inline  ::MemoryHandle::Reader getHandle() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HookLauncher::PrefetchDataParams::Builder {
public:
  typedef PrefetchDataParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHandle();
  inline  ::MemoryHandle::Builder getHandle();
  inline void setHandle( ::MemoryHandle::Reader value);
  inline  ::MemoryHandle::Builder initHandle();
  inline void adoptHandle(::capnp::Orphan< ::MemoryHandle>&& value);
  inline ::capnp::Orphan< ::MemoryHandle> disownHandle();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HookLauncher::PrefetchDataParams::Pipeline {
public:
  typedef PrefetchDataParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::MemoryHandle::Pipeline getHandle();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class HookLauncher::PrefetchDataResults::Reader {
public:
  typedef PrefetchDataResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasAck() const;
  inline  ::Ack::Reader getAck() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HookLauncher::PrefetchDataResults::Builder {
public:
  typedef PrefetchDataResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasAck();
  inline  ::Ack::Builder getAck();
  inline void setAck( ::Ack::Reader value);
  inline  ::Ack::Builder initAck();
  inline void adoptAck(::capnp::Orphan< ::Ack>&& value);
  inline ::capnp::Orphan< ::Ack> disownAck();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HookLauncher::PrefetchDataResults::Pipeline {
public:
  typedef PrefetchDataResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Ack::Pipeline getAck();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class HookLauncher::MeasureBandwidthParams::Reader {
public:
  typedef MeasureBandwidthParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasSrc() const;
  inline  ::capnp::Text::Reader getSrc() const;

  inline bool hasDst() const;
  inline  ::capnp::Text::Reader getDst() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HookLauncher::MeasureBandwidthParams::Builder {
public:
  typedef MeasureBandwidthParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasSrc();
  inline  ::capnp::Text::Builder getSrc();
  inline void setSrc( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initSrc(unsigned int size);
  inline void adoptSrc(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownSrc();

  inline bool hasDst();
  inline  ::capnp::Text::Builder getDst();
  inline void setDst( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initDst(unsigned int size);
  inline void adoptDst(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownDst();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HookLauncher::MeasureBandwidthParams::Pipeline {
public:
  typedef MeasureBandwidthParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class HookLauncher::MeasureBandwidthResults::Reader {
public:
  typedef MeasureBandwidthResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasResult() const;
  inline  ::BandwidthResult::Reader getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HookLauncher::MeasureBandwidthResults::Builder {
public:
  typedef MeasureBandwidthResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResult();
  inline  ::BandwidthResult::Builder getResult();
  inline void setResult( ::BandwidthResult::Reader value);
  inline  ::BandwidthResult::Builder initResult();
  inline void adoptResult(::capnp::Orphan< ::BandwidthResult>&& value);
  inline ::capnp::Orphan< ::BandwidthResult> disownResult();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HookLauncher::MeasureBandwidthResults::Pipeline {
public:
  typedef MeasureBandwidthResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::BandwidthResult::Pipeline getResult();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class HookLauncher::TrackAsyncTaskParams::Reader {
public:
  typedef TrackAsyncTaskParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getTaskId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HookLauncher::TrackAsyncTaskParams::Builder {
public:
  typedef TrackAsyncTaskParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getTaskId();
  inline void setTaskId( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HookLauncher::TrackAsyncTaskParams::Pipeline {
public:
  typedef TrackAsyncTaskParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class HookLauncher::TrackAsyncTaskResults::Reader {
public:
  typedef TrackAsyncTaskResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasStatus() const;
  inline  ::TaskStatus::Reader getStatus() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HookLauncher::TrackAsyncTaskResults::Builder {
public:
  typedef TrackAsyncTaskResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasStatus();
  inline  ::TaskStatus::Builder getStatus();
  inline void setStatus( ::TaskStatus::Reader value);
  inline  ::TaskStatus::Builder initStatus();
  inline void adoptStatus(::capnp::Orphan< ::TaskStatus>&& value);
  inline ::capnp::Orphan< ::TaskStatus> disownStatus();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HookLauncher::TrackAsyncTaskResults::Pipeline {
public:
  typedef TrackAsyncTaskResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::TaskStatus::Pipeline getStatus();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class HookLauncher::GetMemoryLocationParams::Reader {
public:
  typedef GetMemoryLocationParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getFakePtr() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HookLauncher::GetMemoryLocationParams::Builder {
public:
  typedef GetMemoryLocationParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getFakePtr();
  inline void setFakePtr( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HookLauncher::GetMemoryLocationParams::Pipeline {
public:
  typedef GetMemoryLocationParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class HookLauncher::GetMemoryLocationResults::Reader {
public:
  typedef GetMemoryLocationResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasLocation() const;
  inline  ::NodeInfo::Reader getLocation() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HookLauncher::GetMemoryLocationResults::Builder {
public:
  typedef GetMemoryLocationResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasLocation();
  inline  ::NodeInfo::Builder getLocation();
  inline void setLocation( ::NodeInfo::Reader value);
  inline  ::NodeInfo::Builder initLocation();
  inline void adoptLocation(::capnp::Orphan< ::NodeInfo>&& value);
  inline ::capnp::Orphan< ::NodeInfo> disownLocation();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HookLauncher::GetMemoryLocationResults::Pipeline {
public:
  typedef GetMemoryLocationResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::NodeInfo::Pipeline getLocation();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class HookLauncher::AdvisePrefetchParams::Reader {
public:
  typedef AdvisePrefetchParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getFakePtr() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HookLauncher::AdvisePrefetchParams::Builder {
public:
  typedef AdvisePrefetchParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getFakePtr();
  inline void setFakePtr( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HookLauncher::AdvisePrefetchParams::Pipeline {
public:
  typedef AdvisePrefetchParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class HookLauncher::AdvisePrefetchResults::Reader {
public:
  typedef AdvisePrefetchResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasAck() const;
  inline  ::Ack::Reader getAck() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HookLauncher::AdvisePrefetchResults::Builder {
public:
  typedef AdvisePrefetchResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasAck();
  inline  ::Ack::Builder getAck();
  inline void setAck( ::Ack::Reader value);
  inline  ::Ack::Builder initAck();
  inline void adoptAck(::capnp::Orphan< ::Ack>&& value);
  inline ::capnp::Orphan< ::Ack> disownAck();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HookLauncher::AdvisePrefetchResults::Pipeline {
public:
  typedef AdvisePrefetchResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Ack::Pipeline getAck();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BandwidthResult::Reader {
public:
  typedef BandwidthResult Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getThroughput() const;

  inline float getLatency() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BandwidthResult::Builder {
public:
  typedef BandwidthResult Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getThroughput();
  inline void setThroughput(float value);

  inline float getLatency();
  inline void setLatency(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BandwidthResult::Pipeline {
public:
  typedef BandwidthResult Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TaskStatus::Reader {
public:
  typedef TaskStatus Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getProgress() const;

  inline  ::uint32_t getEstimatedTime() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TaskStatus::Builder {
public:
  typedef TaskStatus Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getProgress();
  inline void setProgress( ::uint8_t value);

  inline  ::uint32_t getEstimatedTime();
  inline void setEstimatedTime( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TaskStatus::Pipeline {
public:
  typedef TaskStatus Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class NodeInfo::Reader {
public:
  typedef NodeInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getNodeId() const;

  inline bool hasMemoryType() const;
  inline  ::capnp::Text::Reader getMemoryType() const;

  inline  ::ErrorCode getError() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class NodeInfo::Builder {
public:
  typedef NodeInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getNodeId();
  inline void setNodeId( ::uint32_t value);

  inline bool hasMemoryType();
  inline  ::capnp::Text::Builder getMemoryType();
  inline void setMemoryType( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initMemoryType(unsigned int size);
  inline void adoptMemoryType(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownMemoryType();

  inline  ::ErrorCode getError();
  inline void setError( ::ErrorCode value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class NodeInfo::Pipeline {
public:
  typedef NodeInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline bool MemcpyPlan::Reader::hasTargetServerIp() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool MemcpyPlan::Builder::hasTargetServerIp() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader MemcpyPlan::Reader::getTargetServerIp() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder MemcpyPlan::Builder::getTargetServerIp() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void MemcpyPlan::Builder::setTargetServerIp( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder MemcpyPlan::Builder::initTargetServerIp(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void MemcpyPlan::Builder::adoptTargetServerIp(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> MemcpyPlan::Builder::disownTargetServerIp() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint16_t MemcpyPlan::Reader::getTargetServerZmqPort() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t MemcpyPlan::Builder::getTargetServerZmqPort() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void MemcpyPlan::Builder::setTargetServerZmqPort( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::ErrorCode MemcpyPlan::Reader::getError() const {
  return _reader.getDataField< ::ErrorCode>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::ErrorCode MemcpyPlan::Builder::getError() {
  return _builder.getDataField< ::ErrorCode>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void MemcpyPlan::Builder::setError( ::ErrorCode value) {
  _builder.setDataField< ::ErrorCode>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool NodeStatus::Reader::hasId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool NodeStatus::Builder::hasId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader NodeStatus::Reader::getId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder NodeStatus::Builder::getId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void NodeStatus::Builder::setId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder NodeStatus::Builder::initId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void NodeStatus::Builder::adoptId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> NodeStatus::Builder::disownId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t NodeStatus::Reader::getAvailableMemory() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t NodeStatus::Builder::getAvailableMemory() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void NodeStatus::Builder::setAvailableMemory( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float NodeStatus::Reader::getGpuUtilization() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float NodeStatus::Builder::getGpuUtilization() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void NodeStatus::Builder::setGpuUtilization(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float NodeStatus::Reader::getNetworkLatency() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float NodeStatus::Builder::getNetworkLatency() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void NodeStatus::Builder::setNetworkLatency(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

#if !CAPNP_LITE
inline HookLauncher::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline HookLauncher::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline HookLauncher::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline HookLauncher::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline HookLauncher::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::HookLauncher::Client& HookLauncher::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::HookLauncher::Client& HookLauncher::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool HookLauncher::PlanMemcpyHtoDParams::Reader::hasDstHandle() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool HookLauncher::PlanMemcpyHtoDParams::Builder::hasDstHandle() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::MemoryHandle::Reader HookLauncher::PlanMemcpyHtoDParams::Reader::getDstHandle() const {
  return ::capnp::_::PointerHelpers< ::MemoryHandle>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::MemoryHandle::Builder HookLauncher::PlanMemcpyHtoDParams::Builder::getDstHandle() {
  return ::capnp::_::PointerHelpers< ::MemoryHandle>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::MemoryHandle::Pipeline HookLauncher::PlanMemcpyHtoDParams::Pipeline::getDstHandle() {
  return  ::MemoryHandle::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void HookLauncher::PlanMemcpyHtoDParams::Builder::setDstHandle( ::MemoryHandle::Reader value) {
  ::capnp::_::PointerHelpers< ::MemoryHandle>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::MemoryHandle::Builder HookLauncher::PlanMemcpyHtoDParams::Builder::initDstHandle() {
  return ::capnp::_::PointerHelpers< ::MemoryHandle>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void HookLauncher::PlanMemcpyHtoDParams::Builder::adoptDstHandle(
    ::capnp::Orphan< ::MemoryHandle>&& value) {
  ::capnp::_::PointerHelpers< ::MemoryHandle>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::MemoryHandle> HookLauncher::PlanMemcpyHtoDParams::Builder::disownDstHandle() {
  return ::capnp::_::PointerHelpers< ::MemoryHandle>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t HookLauncher::PlanMemcpyHtoDParams::Reader::getSize() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t HookLauncher::PlanMemcpyHtoDParams::Builder::getSize() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void HookLauncher::PlanMemcpyHtoDParams::Builder::setSize( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool HookLauncher::PlanMemcpyHtoDResults::Reader::hasPlan() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool HookLauncher::PlanMemcpyHtoDResults::Builder::hasPlan() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::MemcpyPlan::Reader HookLauncher::PlanMemcpyHtoDResults::Reader::getPlan() const {
  return ::capnp::_::PointerHelpers< ::MemcpyPlan>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::MemcpyPlan::Builder HookLauncher::PlanMemcpyHtoDResults::Builder::getPlan() {
  return ::capnp::_::PointerHelpers< ::MemcpyPlan>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::MemcpyPlan::Pipeline HookLauncher::PlanMemcpyHtoDResults::Pipeline::getPlan() {
  return  ::MemcpyPlan::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void HookLauncher::PlanMemcpyHtoDResults::Builder::setPlan( ::MemcpyPlan::Reader value) {
  ::capnp::_::PointerHelpers< ::MemcpyPlan>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::MemcpyPlan::Builder HookLauncher::PlanMemcpyHtoDResults::Builder::initPlan() {
  return ::capnp::_::PointerHelpers< ::MemcpyPlan>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void HookLauncher::PlanMemcpyHtoDResults::Builder::adoptPlan(
    ::capnp::Orphan< ::MemcpyPlan>&& value) {
  ::capnp::_::PointerHelpers< ::MemcpyPlan>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::MemcpyPlan> HookLauncher::PlanMemcpyHtoDResults::Builder::disownPlan() {
  return ::capnp::_::PointerHelpers< ::MemcpyPlan>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool HookLauncher::PlanMemcpyDtoHParams::Reader::hasSrcHandle() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool HookLauncher::PlanMemcpyDtoHParams::Builder::hasSrcHandle() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::MemoryHandle::Reader HookLauncher::PlanMemcpyDtoHParams::Reader::getSrcHandle() const {
  return ::capnp::_::PointerHelpers< ::MemoryHandle>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::MemoryHandle::Builder HookLauncher::PlanMemcpyDtoHParams::Builder::getSrcHandle() {
  return ::capnp::_::PointerHelpers< ::MemoryHandle>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::MemoryHandle::Pipeline HookLauncher::PlanMemcpyDtoHParams::Pipeline::getSrcHandle() {
  return  ::MemoryHandle::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void HookLauncher::PlanMemcpyDtoHParams::Builder::setSrcHandle( ::MemoryHandle::Reader value) {
  ::capnp::_::PointerHelpers< ::MemoryHandle>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::MemoryHandle::Builder HookLauncher::PlanMemcpyDtoHParams::Builder::initSrcHandle() {
  return ::capnp::_::PointerHelpers< ::MemoryHandle>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void HookLauncher::PlanMemcpyDtoHParams::Builder::adoptSrcHandle(
    ::capnp::Orphan< ::MemoryHandle>&& value) {
  ::capnp::_::PointerHelpers< ::MemoryHandle>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::MemoryHandle> HookLauncher::PlanMemcpyDtoHParams::Builder::disownSrcHandle() {
  return ::capnp::_::PointerHelpers< ::MemoryHandle>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t HookLauncher::PlanMemcpyDtoHParams::Reader::getSize() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t HookLauncher::PlanMemcpyDtoHParams::Builder::getSize() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void HookLauncher::PlanMemcpyDtoHParams::Builder::setSize( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool HookLauncher::PlanMemcpyDtoHResults::Reader::hasPlan() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool HookLauncher::PlanMemcpyDtoHResults::Builder::hasPlan() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::MemcpyPlan::Reader HookLauncher::PlanMemcpyDtoHResults::Reader::getPlan() const {
  return ::capnp::_::PointerHelpers< ::MemcpyPlan>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::MemcpyPlan::Builder HookLauncher::PlanMemcpyDtoHResults::Builder::getPlan() {
  return ::capnp::_::PointerHelpers< ::MemcpyPlan>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::MemcpyPlan::Pipeline HookLauncher::PlanMemcpyDtoHResults::Pipeline::getPlan() {
  return  ::MemcpyPlan::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void HookLauncher::PlanMemcpyDtoHResults::Builder::setPlan( ::MemcpyPlan::Reader value) {
  ::capnp::_::PointerHelpers< ::MemcpyPlan>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::MemcpyPlan::Builder HookLauncher::PlanMemcpyDtoHResults::Builder::initPlan() {
  return ::capnp::_::PointerHelpers< ::MemcpyPlan>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void HookLauncher::PlanMemcpyDtoHResults::Builder::adoptPlan(
    ::capnp::Orphan< ::MemcpyPlan>&& value) {
  ::capnp::_::PointerHelpers< ::MemcpyPlan>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::MemcpyPlan> HookLauncher::PlanMemcpyDtoHResults::Builder::disownPlan() {
  return ::capnp::_::PointerHelpers< ::MemcpyPlan>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool HookLauncher::GetNodeStatusResults::Reader::hasNodes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool HookLauncher::GetNodeStatusResults::Builder::hasNodes() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>::Reader HookLauncher::GetNodeStatusResults::Reader::getNodes() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>::Builder HookLauncher::GetNodeStatusResults::Builder::getNodes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void HookLauncher::GetNodeStatusResults::Builder::setNodes( ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>::Builder HookLauncher::GetNodeStatusResults::Builder::initNodes(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void HookLauncher::GetNodeStatusResults::Builder::adoptNodes(
    ::capnp::Orphan< ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>> HookLauncher::GetNodeStatusResults::Builder::disownNodes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool HookLauncher::PrefetchDataParams::Reader::hasHandle() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool HookLauncher::PrefetchDataParams::Builder::hasHandle() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::MemoryHandle::Reader HookLauncher::PrefetchDataParams::Reader::getHandle() const {
  return ::capnp::_::PointerHelpers< ::MemoryHandle>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::MemoryHandle::Builder HookLauncher::PrefetchDataParams::Builder::getHandle() {
  return ::capnp::_::PointerHelpers< ::MemoryHandle>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::MemoryHandle::Pipeline HookLauncher::PrefetchDataParams::Pipeline::getHandle() {
  return  ::MemoryHandle::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void HookLauncher::PrefetchDataParams::Builder::setHandle( ::MemoryHandle::Reader value) {
  ::capnp::_::PointerHelpers< ::MemoryHandle>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::MemoryHandle::Builder HookLauncher::PrefetchDataParams::Builder::initHandle() {
  return ::capnp::_::PointerHelpers< ::MemoryHandle>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void HookLauncher::PrefetchDataParams::Builder::adoptHandle(
    ::capnp::Orphan< ::MemoryHandle>&& value) {
  ::capnp::_::PointerHelpers< ::MemoryHandle>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::MemoryHandle> HookLauncher::PrefetchDataParams::Builder::disownHandle() {
  return ::capnp::_::PointerHelpers< ::MemoryHandle>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool HookLauncher::PrefetchDataResults::Reader::hasAck() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool HookLauncher::PrefetchDataResults::Builder::hasAck() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Ack::Reader HookLauncher::PrefetchDataResults::Reader::getAck() const {
  return ::capnp::_::PointerHelpers< ::Ack>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Ack::Builder HookLauncher::PrefetchDataResults::Builder::getAck() {
  return ::capnp::_::PointerHelpers< ::Ack>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Ack::Pipeline HookLauncher::PrefetchDataResults::Pipeline::getAck() {
  return  ::Ack::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void HookLauncher::PrefetchDataResults::Builder::setAck( ::Ack::Reader value) {
  ::capnp::_::PointerHelpers< ::Ack>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Ack::Builder HookLauncher::PrefetchDataResults::Builder::initAck() {
  return ::capnp::_::PointerHelpers< ::Ack>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void HookLauncher::PrefetchDataResults::Builder::adoptAck(
    ::capnp::Orphan< ::Ack>&& value) {
  ::capnp::_::PointerHelpers< ::Ack>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Ack> HookLauncher::PrefetchDataResults::Builder::disownAck() {
  return ::capnp::_::PointerHelpers< ::Ack>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool HookLauncher::MeasureBandwidthParams::Reader::hasSrc() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool HookLauncher::MeasureBandwidthParams::Builder::hasSrc() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader HookLauncher::MeasureBandwidthParams::Reader::getSrc() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder HookLauncher::MeasureBandwidthParams::Builder::getSrc() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void HookLauncher::MeasureBandwidthParams::Builder::setSrc( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder HookLauncher::MeasureBandwidthParams::Builder::initSrc(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void HookLauncher::MeasureBandwidthParams::Builder::adoptSrc(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> HookLauncher::MeasureBandwidthParams::Builder::disownSrc() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool HookLauncher::MeasureBandwidthParams::Reader::hasDst() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool HookLauncher::MeasureBandwidthParams::Builder::hasDst() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader HookLauncher::MeasureBandwidthParams::Reader::getDst() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder HookLauncher::MeasureBandwidthParams::Builder::getDst() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void HookLauncher::MeasureBandwidthParams::Builder::setDst( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder HookLauncher::MeasureBandwidthParams::Builder::initDst(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void HookLauncher::MeasureBandwidthParams::Builder::adoptDst(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> HookLauncher::MeasureBandwidthParams::Builder::disownDst() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool HookLauncher::MeasureBandwidthResults::Reader::hasResult() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool HookLauncher::MeasureBandwidthResults::Builder::hasResult() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::BandwidthResult::Reader HookLauncher::MeasureBandwidthResults::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::BandwidthResult>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::BandwidthResult::Builder HookLauncher::MeasureBandwidthResults::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::BandwidthResult>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::BandwidthResult::Pipeline HookLauncher::MeasureBandwidthResults::Pipeline::getResult() {
  return  ::BandwidthResult::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void HookLauncher::MeasureBandwidthResults::Builder::setResult( ::BandwidthResult::Reader value) {
  ::capnp::_::PointerHelpers< ::BandwidthResult>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::BandwidthResult::Builder HookLauncher::MeasureBandwidthResults::Builder::initResult() {
  return ::capnp::_::PointerHelpers< ::BandwidthResult>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void HookLauncher::MeasureBandwidthResults::Builder::adoptResult(
    ::capnp::Orphan< ::BandwidthResult>&& value) {
  ::capnp::_::PointerHelpers< ::BandwidthResult>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::BandwidthResult> HookLauncher::MeasureBandwidthResults::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::BandwidthResult>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t HookLauncher::TrackAsyncTaskParams::Reader::getTaskId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t HookLauncher::TrackAsyncTaskParams::Builder::getTaskId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void HookLauncher::TrackAsyncTaskParams::Builder::setTaskId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool HookLauncher::TrackAsyncTaskResults::Reader::hasStatus() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool HookLauncher::TrackAsyncTaskResults::Builder::hasStatus() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::TaskStatus::Reader HookLauncher::TrackAsyncTaskResults::Reader::getStatus() const {
  return ::capnp::_::PointerHelpers< ::TaskStatus>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::TaskStatus::Builder HookLauncher::TrackAsyncTaskResults::Builder::getStatus() {
  return ::capnp::_::PointerHelpers< ::TaskStatus>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::TaskStatus::Pipeline HookLauncher::TrackAsyncTaskResults::Pipeline::getStatus() {
  return  ::TaskStatus::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void HookLauncher::TrackAsyncTaskResults::Builder::setStatus( ::TaskStatus::Reader value) {
  ::capnp::_::PointerHelpers< ::TaskStatus>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::TaskStatus::Builder HookLauncher::TrackAsyncTaskResults::Builder::initStatus() {
  return ::capnp::_::PointerHelpers< ::TaskStatus>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void HookLauncher::TrackAsyncTaskResults::Builder::adoptStatus(
    ::capnp::Orphan< ::TaskStatus>&& value) {
  ::capnp::_::PointerHelpers< ::TaskStatus>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::TaskStatus> HookLauncher::TrackAsyncTaskResults::Builder::disownStatus() {
  return ::capnp::_::PointerHelpers< ::TaskStatus>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t HookLauncher::GetMemoryLocationParams::Reader::getFakePtr() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t HookLauncher::GetMemoryLocationParams::Builder::getFakePtr() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void HookLauncher::GetMemoryLocationParams::Builder::setFakePtr( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool HookLauncher::GetMemoryLocationResults::Reader::hasLocation() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool HookLauncher::GetMemoryLocationResults::Builder::hasLocation() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::NodeInfo::Reader HookLauncher::GetMemoryLocationResults::Reader::getLocation() const {
  return ::capnp::_::PointerHelpers< ::NodeInfo>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::NodeInfo::Builder HookLauncher::GetMemoryLocationResults::Builder::getLocation() {
  return ::capnp::_::PointerHelpers< ::NodeInfo>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::NodeInfo::Pipeline HookLauncher::GetMemoryLocationResults::Pipeline::getLocation() {
  return  ::NodeInfo::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void HookLauncher::GetMemoryLocationResults::Builder::setLocation( ::NodeInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::NodeInfo>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::NodeInfo::Builder HookLauncher::GetMemoryLocationResults::Builder::initLocation() {
  return ::capnp::_::PointerHelpers< ::NodeInfo>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void HookLauncher::GetMemoryLocationResults::Builder::adoptLocation(
    ::capnp::Orphan< ::NodeInfo>&& value) {
  ::capnp::_::PointerHelpers< ::NodeInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::NodeInfo> HookLauncher::GetMemoryLocationResults::Builder::disownLocation() {
  return ::capnp::_::PointerHelpers< ::NodeInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t HookLauncher::AdvisePrefetchParams::Reader::getFakePtr() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t HookLauncher::AdvisePrefetchParams::Builder::getFakePtr() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void HookLauncher::AdvisePrefetchParams::Builder::setFakePtr( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool HookLauncher::AdvisePrefetchResults::Reader::hasAck() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool HookLauncher::AdvisePrefetchResults::Builder::hasAck() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Ack::Reader HookLauncher::AdvisePrefetchResults::Reader::getAck() const {
  return ::capnp::_::PointerHelpers< ::Ack>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Ack::Builder HookLauncher::AdvisePrefetchResults::Builder::getAck() {
  return ::capnp::_::PointerHelpers< ::Ack>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Ack::Pipeline HookLauncher::AdvisePrefetchResults::Pipeline::getAck() {
  return  ::Ack::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void HookLauncher::AdvisePrefetchResults::Builder::setAck( ::Ack::Reader value) {
  ::capnp::_::PointerHelpers< ::Ack>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Ack::Builder HookLauncher::AdvisePrefetchResults::Builder::initAck() {
  return ::capnp::_::PointerHelpers< ::Ack>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void HookLauncher::AdvisePrefetchResults::Builder::adoptAck(
    ::capnp::Orphan< ::Ack>&& value) {
  ::capnp::_::PointerHelpers< ::Ack>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Ack> HookLauncher::AdvisePrefetchResults::Builder::disownAck() {
  return ::capnp::_::PointerHelpers< ::Ack>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline float BandwidthResult::Reader::getThroughput() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float BandwidthResult::Builder::getThroughput() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void BandwidthResult::Builder::setThroughput(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float BandwidthResult::Reader::getLatency() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float BandwidthResult::Builder::getLatency() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void BandwidthResult::Builder::setLatency(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t TaskStatus::Reader::getProgress() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t TaskStatus::Builder::getProgress() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TaskStatus::Builder::setProgress( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t TaskStatus::Reader::getEstimatedTime() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t TaskStatus::Builder::getEstimatedTime() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void TaskStatus::Builder::setEstimatedTime( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t NodeInfo::Reader::getNodeId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t NodeInfo::Builder::getNodeId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void NodeInfo::Builder::setNodeId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool NodeInfo::Reader::hasMemoryType() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool NodeInfo::Builder::hasMemoryType() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader NodeInfo::Reader::getMemoryType() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder NodeInfo::Builder::getMemoryType() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void NodeInfo::Builder::setMemoryType( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder NodeInfo::Builder::initMemoryType(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void NodeInfo::Builder::adoptMemoryType(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> NodeInfo::Builder::disownMemoryType() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::ErrorCode NodeInfo::Reader::getError() const {
  return _reader.getDataField< ::ErrorCode>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::ErrorCode NodeInfo::Builder::getError() {
  return _builder.getDataField< ::ErrorCode>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void NodeInfo::Builder::setError( ::ErrorCode value) {
  _builder.setDataField< ::ErrorCode>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}


CAPNP_END_HEADER

