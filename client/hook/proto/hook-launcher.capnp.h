// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: hook-launcher.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>
#if !CAPNP_LITE
#include <capnp/capability.h>
#endif  // !CAPNP_LITE

#ifndef CAPNP_VERSION
#error "CAPNP_VERSION is not defined, is capnp/generated-header-support.h missing?"
#elif CAPNP_VERSION != 1002000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include "common.capnp.h"

CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(9a6ef642818fc4ee);
CAPNP_DECLARE_SCHEMA(ddb256ee5b6b53b3);
CAPNP_DECLARE_SCHEMA(eb7186a22c3fa0de);
CAPNP_DECLARE_SCHEMA(b5d15336d30e0dd1);
CAPNP_DECLARE_SCHEMA(a000d051b28a6d94);
CAPNP_DECLARE_SCHEMA(d9ccdb1e5a73a940);
CAPNP_DECLARE_SCHEMA(eb3523cbe98a804f);
CAPNP_DECLARE_SCHEMA(fa389ebe41e98f39);
CAPNP_DECLARE_SCHEMA(80b6bbac6ed09d85);
CAPNP_DECLARE_SCHEMA(e76522c9a2f40b20);
CAPNP_DECLARE_SCHEMA(befc738967da08f4);
CAPNP_DECLARE_SCHEMA(cbbd2a831eac2f20);
CAPNP_DECLARE_SCHEMA(a4ab519fa8915cb7);
CAPNP_DECLARE_SCHEMA(8cad8defaf95e7b0);
CAPNP_DECLARE_SCHEMA(bb47eae7bc02e6df);
CAPNP_DECLARE_SCHEMA(8164a155f1640357);

}  // namespace schemas
}  // namespace capnp


struct AllocationResult {
  AllocationResult() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9a6ef642818fc4ee, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct MemcpyPlan {
  MemcpyPlan() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ddb256ee5b6b53b3, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct NodeStatus {
  NodeStatus() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(eb7186a22c3fa0de, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HookLauncher {
  HookLauncher() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct RequestAllocationParams;
  struct RequestAllocationResults;
  struct RequestFreeParams;
  struct RequestFreeResults;
  struct PlanMemcpyHtoDParams;
  struct PlanMemcpyHtoDResults;
  struct PlanMemcpyDtoHParams;
  struct PlanMemcpyDtoHResults;
  struct LaunchKernelParams;
  struct LaunchKernelResults;
  struct GetNodeStatusParams;
  struct GetNodeStatusResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(b5d15336d30e0dd1)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct HookLauncher::RequestAllocationParams {
  RequestAllocationParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a000d051b28a6d94, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HookLauncher::RequestAllocationResults {
  RequestAllocationResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d9ccdb1e5a73a940, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HookLauncher::RequestFreeParams {
  RequestFreeParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(eb3523cbe98a804f, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HookLauncher::RequestFreeResults {
  RequestFreeResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fa389ebe41e98f39, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HookLauncher::PlanMemcpyHtoDParams {
  PlanMemcpyHtoDParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(80b6bbac6ed09d85, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HookLauncher::PlanMemcpyHtoDResults {
  PlanMemcpyHtoDResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e76522c9a2f40b20, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HookLauncher::PlanMemcpyDtoHParams {
  PlanMemcpyDtoHParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(befc738967da08f4, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HookLauncher::PlanMemcpyDtoHResults {
  PlanMemcpyDtoHResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cbbd2a831eac2f20, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HookLauncher::LaunchKernelParams {
  LaunchKernelParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a4ab519fa8915cb7, 2, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HookLauncher::LaunchKernelResults {
  LaunchKernelResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8cad8defaf95e7b0, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HookLauncher::GetNodeStatusParams {
  GetNodeStatusParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bb47eae7bc02e6df, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HookLauncher::GetNodeStatusResults {
  GetNodeStatusResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8164a155f1640357, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class AllocationResult::Reader {
public:
  typedef AllocationResult Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getFakePtr() const;

  inline  ::ErrorCode getError() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AllocationResult::Builder {
public:
  typedef AllocationResult Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getFakePtr();
  inline void setFakePtr( ::uint64_t value);

  inline  ::ErrorCode getError();
  inline void setError( ::ErrorCode value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AllocationResult::Pipeline {
public:
  typedef AllocationResult Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MemcpyPlan::Reader {
public:
  typedef MemcpyPlan Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTargetServerIp() const;
  inline  ::capnp::Text::Reader getTargetServerIp() const;

  inline  ::uint32_t getTargetServerRdmaPort() const;

  inline  ::uint64_t getRemotePtr() const;

  inline  ::ErrorCode getError() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MemcpyPlan::Builder {
public:
  typedef MemcpyPlan Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTargetServerIp();
  inline  ::capnp::Text::Builder getTargetServerIp();
  inline void setTargetServerIp( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initTargetServerIp(unsigned int size);
  inline void adoptTargetServerIp(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownTargetServerIp();

  inline  ::uint32_t getTargetServerRdmaPort();
  inline void setTargetServerRdmaPort( ::uint32_t value);

  inline  ::uint64_t getRemotePtr();
  inline void setRemotePtr( ::uint64_t value);

  inline  ::ErrorCode getError();
  inline void setError( ::ErrorCode value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MemcpyPlan::Pipeline {
public:
  typedef MemcpyPlan Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class NodeStatus::Reader {
public:
  typedef NodeStatus Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasId() const;
  inline  ::capnp::Text::Reader getId() const;

  inline  ::uint64_t getAvailableMemory() const;

  inline float getGpuUtilization() const;

  inline float getNetworkLatency() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class NodeStatus::Builder {
public:
  typedef NodeStatus Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasId();
  inline  ::capnp::Text::Builder getId();
  inline void setId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initId(unsigned int size);
  inline void adoptId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownId();

  inline  ::uint64_t getAvailableMemory();
  inline void setAvailableMemory( ::uint64_t value);

  inline float getGpuUtilization();
  inline void setGpuUtilization(float value);

  inline float getNetworkLatency();
  inline void setNetworkLatency(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class NodeStatus::Pipeline {
public:
  typedef NodeStatus Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class HookLauncher::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef HookLauncher Calls;
  typedef HookLauncher Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::HookLauncher::RequestAllocationParams,  ::HookLauncher::RequestAllocationResults> requestAllocationRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::HookLauncher::RequestFreeParams,  ::HookLauncher::RequestFreeResults> requestFreeRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::HookLauncher::PlanMemcpyHtoDParams,  ::HookLauncher::PlanMemcpyHtoDResults> planMemcpyHtoDRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::HookLauncher::PlanMemcpyDtoHParams,  ::HookLauncher::PlanMemcpyDtoHResults> planMemcpyDtoHRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::HookLauncher::LaunchKernelParams,  ::HookLauncher::LaunchKernelResults> launchKernelRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::HookLauncher::GetNodeStatusParams,  ::HookLauncher::GetNodeStatusResults> getNodeStatusRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class HookLauncher::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef HookLauncher Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::HookLauncher::RequestAllocationParams RequestAllocationParams;
  typedef  ::HookLauncher::RequestAllocationResults RequestAllocationResults;
  typedef ::capnp::CallContext<RequestAllocationParams, RequestAllocationResults> RequestAllocationContext;
  virtual ::kj::Promise<void> requestAllocation(RequestAllocationContext context);
  typedef  ::HookLauncher::RequestFreeParams RequestFreeParams;
  typedef  ::HookLauncher::RequestFreeResults RequestFreeResults;
  typedef ::capnp::CallContext<RequestFreeParams, RequestFreeResults> RequestFreeContext;
  virtual ::kj::Promise<void> requestFree(RequestFreeContext context);
  typedef  ::HookLauncher::PlanMemcpyHtoDParams PlanMemcpyHtoDParams;
  typedef  ::HookLauncher::PlanMemcpyHtoDResults PlanMemcpyHtoDResults;
  typedef ::capnp::CallContext<PlanMemcpyHtoDParams, PlanMemcpyHtoDResults> PlanMemcpyHtoDContext;
  virtual ::kj::Promise<void> planMemcpyHtoD(PlanMemcpyHtoDContext context);
  typedef  ::HookLauncher::PlanMemcpyDtoHParams PlanMemcpyDtoHParams;
  typedef  ::HookLauncher::PlanMemcpyDtoHResults PlanMemcpyDtoHResults;
  typedef ::capnp::CallContext<PlanMemcpyDtoHParams, PlanMemcpyDtoHResults> PlanMemcpyDtoHContext;
  virtual ::kj::Promise<void> planMemcpyDtoH(PlanMemcpyDtoHContext context);
  typedef  ::HookLauncher::LaunchKernelParams LaunchKernelParams;
  typedef  ::HookLauncher::LaunchKernelResults LaunchKernelResults;
  typedef ::capnp::CallContext<LaunchKernelParams, LaunchKernelResults> LaunchKernelContext;
  virtual ::kj::Promise<void> launchKernel(LaunchKernelContext context);
  typedef  ::HookLauncher::GetNodeStatusParams GetNodeStatusParams;
  typedef  ::HookLauncher::GetNodeStatusResults GetNodeStatusResults;
  typedef ::capnp::CallContext<GetNodeStatusParams, GetNodeStatusResults> GetNodeStatusContext;
  virtual ::kj::Promise<void> getNodeStatus(GetNodeStatusContext context);

  inline  ::HookLauncher::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::HookLauncher>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class HookLauncher::RequestAllocationParams::Reader {
public:
  typedef RequestAllocationParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getSize() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HookLauncher::RequestAllocationParams::Builder {
public:
  typedef RequestAllocationParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getSize();
  inline void setSize( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HookLauncher::RequestAllocationParams::Pipeline {
public:
  typedef RequestAllocationParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class HookLauncher::RequestAllocationResults::Reader {
public:
  typedef RequestAllocationResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasResult() const;
  inline  ::AllocationResult::Reader getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HookLauncher::RequestAllocationResults::Builder {
public:
  typedef RequestAllocationResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResult();
  inline  ::AllocationResult::Builder getResult();
  inline void setResult( ::AllocationResult::Reader value);
  inline  ::AllocationResult::Builder initResult();
  inline void adoptResult(::capnp::Orphan< ::AllocationResult>&& value);
  inline ::capnp::Orphan< ::AllocationResult> disownResult();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HookLauncher::RequestAllocationResults::Pipeline {
public:
  typedef RequestAllocationResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::AllocationResult::Pipeline getResult();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class HookLauncher::RequestFreeParams::Reader {
public:
  typedef RequestFreeParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getFakePtr() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HookLauncher::RequestFreeParams::Builder {
public:
  typedef RequestFreeParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getFakePtr();
  inline void setFakePtr( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HookLauncher::RequestFreeParams::Pipeline {
public:
  typedef RequestFreeParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class HookLauncher::RequestFreeResults::Reader {
public:
  typedef RequestFreeResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::ErrorCode getError() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HookLauncher::RequestFreeResults::Builder {
public:
  typedef RequestFreeResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::ErrorCode getError();
  inline void setError( ::ErrorCode value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HookLauncher::RequestFreeResults::Pipeline {
public:
  typedef RequestFreeResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class HookLauncher::PlanMemcpyHtoDParams::Reader {
public:
  typedef PlanMemcpyHtoDParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getDstFakePtr() const;

  inline  ::uint64_t getSize() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HookLauncher::PlanMemcpyHtoDParams::Builder {
public:
  typedef PlanMemcpyHtoDParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getDstFakePtr();
  inline void setDstFakePtr( ::uint64_t value);

  inline  ::uint64_t getSize();
  inline void setSize( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HookLauncher::PlanMemcpyHtoDParams::Pipeline {
public:
  typedef PlanMemcpyHtoDParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class HookLauncher::PlanMemcpyHtoDResults::Reader {
public:
  typedef PlanMemcpyHtoDResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPlan() const;
  inline  ::MemcpyPlan::Reader getPlan() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HookLauncher::PlanMemcpyHtoDResults::Builder {
public:
  typedef PlanMemcpyHtoDResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPlan();
  inline  ::MemcpyPlan::Builder getPlan();
  inline void setPlan( ::MemcpyPlan::Reader value);
  inline  ::MemcpyPlan::Builder initPlan();
  inline void adoptPlan(::capnp::Orphan< ::MemcpyPlan>&& value);
  inline ::capnp::Orphan< ::MemcpyPlan> disownPlan();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HookLauncher::PlanMemcpyHtoDResults::Pipeline {
public:
  typedef PlanMemcpyHtoDResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::MemcpyPlan::Pipeline getPlan();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class HookLauncher::PlanMemcpyDtoHParams::Reader {
public:
  typedef PlanMemcpyDtoHParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getSrcFakePtr() const;

  inline  ::uint64_t getSize() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HookLauncher::PlanMemcpyDtoHParams::Builder {
public:
  typedef PlanMemcpyDtoHParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getSrcFakePtr();
  inline void setSrcFakePtr( ::uint64_t value);

  inline  ::uint64_t getSize();
  inline void setSize( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HookLauncher::PlanMemcpyDtoHParams::Pipeline {
public:
  typedef PlanMemcpyDtoHParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class HookLauncher::PlanMemcpyDtoHResults::Reader {
public:
  typedef PlanMemcpyDtoHResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPlan() const;
  inline  ::MemcpyPlan::Reader getPlan() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HookLauncher::PlanMemcpyDtoHResults::Builder {
public:
  typedef PlanMemcpyDtoHResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPlan();
  inline  ::MemcpyPlan::Builder getPlan();
  inline void setPlan( ::MemcpyPlan::Reader value);
  inline  ::MemcpyPlan::Builder initPlan();
  inline void adoptPlan(::capnp::Orphan< ::MemcpyPlan>&& value);
  inline ::capnp::Orphan< ::MemcpyPlan> disownPlan();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HookLauncher::PlanMemcpyDtoHResults::Pipeline {
public:
  typedef PlanMemcpyDtoHResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::MemcpyPlan::Pipeline getPlan();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class HookLauncher::LaunchKernelParams::Reader {
public:
  typedef LaunchKernelParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasFunc() const;
  inline  ::capnp::Text::Reader getFunc() const;

  inline  ::uint32_t getGridDim() const;

  inline  ::uint32_t getBlockDim() const;

  inline  ::uint32_t getSharedMem() const;

  inline bool hasParams() const;
  inline  ::capnp::Data::Reader getParams() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HookLauncher::LaunchKernelParams::Builder {
public:
  typedef LaunchKernelParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasFunc();
  inline  ::capnp::Text::Builder getFunc();
  inline void setFunc( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initFunc(unsigned int size);
  inline void adoptFunc(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownFunc();

  inline  ::uint32_t getGridDim();
  inline void setGridDim( ::uint32_t value);

  inline  ::uint32_t getBlockDim();
  inline void setBlockDim( ::uint32_t value);

  inline  ::uint32_t getSharedMem();
  inline void setSharedMem( ::uint32_t value);

  inline bool hasParams();
  inline  ::capnp::Data::Builder getParams();
  inline void setParams( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initParams(unsigned int size);
  inline void adoptParams(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownParams();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HookLauncher::LaunchKernelParams::Pipeline {
public:
  typedef LaunchKernelParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class HookLauncher::LaunchKernelResults::Reader {
public:
  typedef LaunchKernelResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::ErrorCode getError() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HookLauncher::LaunchKernelResults::Builder {
public:
  typedef LaunchKernelResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::ErrorCode getError();
  inline void setError( ::ErrorCode value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HookLauncher::LaunchKernelResults::Pipeline {
public:
  typedef LaunchKernelResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class HookLauncher::GetNodeStatusParams::Reader {
public:
  typedef GetNodeStatusParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HookLauncher::GetNodeStatusParams::Builder {
public:
  typedef GetNodeStatusParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HookLauncher::GetNodeStatusParams::Pipeline {
public:
  typedef GetNodeStatusParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class HookLauncher::GetNodeStatusResults::Reader {
public:
  typedef GetNodeStatusResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasNodes() const;
  inline  ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>::Reader getNodes() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HookLauncher::GetNodeStatusResults::Builder {
public:
  typedef GetNodeStatusResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasNodes();
  inline  ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>::Builder getNodes();
  inline void setNodes( ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>::Builder initNodes(unsigned int size);
  inline void adoptNodes(::capnp::Orphan< ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>> disownNodes();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HookLauncher::GetNodeStatusResults::Pipeline {
public:
  typedef GetNodeStatusResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::uint64_t AllocationResult::Reader::getFakePtr() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t AllocationResult::Builder::getFakePtr() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AllocationResult::Builder::setFakePtr( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::ErrorCode AllocationResult::Reader::getError() const {
  return _reader.getDataField< ::ErrorCode>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::ErrorCode AllocationResult::Builder::getError() {
  return _builder.getDataField< ::ErrorCode>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void AllocationResult::Builder::setError( ::ErrorCode value) {
  _builder.setDataField< ::ErrorCode>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline bool MemcpyPlan::Reader::hasTargetServerIp() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool MemcpyPlan::Builder::hasTargetServerIp() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader MemcpyPlan::Reader::getTargetServerIp() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder MemcpyPlan::Builder::getTargetServerIp() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void MemcpyPlan::Builder::setTargetServerIp( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder MemcpyPlan::Builder::initTargetServerIp(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void MemcpyPlan::Builder::adoptTargetServerIp(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> MemcpyPlan::Builder::disownTargetServerIp() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t MemcpyPlan::Reader::getTargetServerRdmaPort() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t MemcpyPlan::Builder::getTargetServerRdmaPort() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void MemcpyPlan::Builder::setTargetServerRdmaPort( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t MemcpyPlan::Reader::getRemotePtr() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t MemcpyPlan::Builder::getRemotePtr() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void MemcpyPlan::Builder::setRemotePtr( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::ErrorCode MemcpyPlan::Reader::getError() const {
  return _reader.getDataField< ::ErrorCode>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::ErrorCode MemcpyPlan::Builder::getError() {
  return _builder.getDataField< ::ErrorCode>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void MemcpyPlan::Builder::setError( ::ErrorCode value) {
  _builder.setDataField< ::ErrorCode>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool NodeStatus::Reader::hasId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool NodeStatus::Builder::hasId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader NodeStatus::Reader::getId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder NodeStatus::Builder::getId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void NodeStatus::Builder::setId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder NodeStatus::Builder::initId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void NodeStatus::Builder::adoptId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> NodeStatus::Builder::disownId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t NodeStatus::Reader::getAvailableMemory() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t NodeStatus::Builder::getAvailableMemory() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void NodeStatus::Builder::setAvailableMemory( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float NodeStatus::Reader::getGpuUtilization() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float NodeStatus::Builder::getGpuUtilization() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void NodeStatus::Builder::setGpuUtilization(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float NodeStatus::Reader::getNetworkLatency() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float NodeStatus::Builder::getNetworkLatency() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void NodeStatus::Builder::setNetworkLatency(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

#if !CAPNP_LITE
inline HookLauncher::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline HookLauncher::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline HookLauncher::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline HookLauncher::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline HookLauncher::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::HookLauncher::Client& HookLauncher::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::HookLauncher::Client& HookLauncher::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline  ::uint64_t HookLauncher::RequestAllocationParams::Reader::getSize() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t HookLauncher::RequestAllocationParams::Builder::getSize() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void HookLauncher::RequestAllocationParams::Builder::setSize( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool HookLauncher::RequestAllocationResults::Reader::hasResult() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool HookLauncher::RequestAllocationResults::Builder::hasResult() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::AllocationResult::Reader HookLauncher::RequestAllocationResults::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::AllocationResult>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::AllocationResult::Builder HookLauncher::RequestAllocationResults::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::AllocationResult>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AllocationResult::Pipeline HookLauncher::RequestAllocationResults::Pipeline::getResult() {
  return  ::AllocationResult::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void HookLauncher::RequestAllocationResults::Builder::setResult( ::AllocationResult::Reader value) {
  ::capnp::_::PointerHelpers< ::AllocationResult>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::AllocationResult::Builder HookLauncher::RequestAllocationResults::Builder::initResult() {
  return ::capnp::_::PointerHelpers< ::AllocationResult>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void HookLauncher::RequestAllocationResults::Builder::adoptResult(
    ::capnp::Orphan< ::AllocationResult>&& value) {
  ::capnp::_::PointerHelpers< ::AllocationResult>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AllocationResult> HookLauncher::RequestAllocationResults::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::AllocationResult>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t HookLauncher::RequestFreeParams::Reader::getFakePtr() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t HookLauncher::RequestFreeParams::Builder::getFakePtr() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void HookLauncher::RequestFreeParams::Builder::setFakePtr( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::ErrorCode HookLauncher::RequestFreeResults::Reader::getError() const {
  return _reader.getDataField< ::ErrorCode>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::ErrorCode HookLauncher::RequestFreeResults::Builder::getError() {
  return _builder.getDataField< ::ErrorCode>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void HookLauncher::RequestFreeResults::Builder::setError( ::ErrorCode value) {
  _builder.setDataField< ::ErrorCode>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t HookLauncher::PlanMemcpyHtoDParams::Reader::getDstFakePtr() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t HookLauncher::PlanMemcpyHtoDParams::Builder::getDstFakePtr() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void HookLauncher::PlanMemcpyHtoDParams::Builder::setDstFakePtr( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t HookLauncher::PlanMemcpyHtoDParams::Reader::getSize() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t HookLauncher::PlanMemcpyHtoDParams::Builder::getSize() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void HookLauncher::PlanMemcpyHtoDParams::Builder::setSize( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool HookLauncher::PlanMemcpyHtoDResults::Reader::hasPlan() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool HookLauncher::PlanMemcpyHtoDResults::Builder::hasPlan() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::MemcpyPlan::Reader HookLauncher::PlanMemcpyHtoDResults::Reader::getPlan() const {
  return ::capnp::_::PointerHelpers< ::MemcpyPlan>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::MemcpyPlan::Builder HookLauncher::PlanMemcpyHtoDResults::Builder::getPlan() {
  return ::capnp::_::PointerHelpers< ::MemcpyPlan>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::MemcpyPlan::Pipeline HookLauncher::PlanMemcpyHtoDResults::Pipeline::getPlan() {
  return  ::MemcpyPlan::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void HookLauncher::PlanMemcpyHtoDResults::Builder::setPlan( ::MemcpyPlan::Reader value) {
  ::capnp::_::PointerHelpers< ::MemcpyPlan>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::MemcpyPlan::Builder HookLauncher::PlanMemcpyHtoDResults::Builder::initPlan() {
  return ::capnp::_::PointerHelpers< ::MemcpyPlan>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void HookLauncher::PlanMemcpyHtoDResults::Builder::adoptPlan(
    ::capnp::Orphan< ::MemcpyPlan>&& value) {
  ::capnp::_::PointerHelpers< ::MemcpyPlan>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::MemcpyPlan> HookLauncher::PlanMemcpyHtoDResults::Builder::disownPlan() {
  return ::capnp::_::PointerHelpers< ::MemcpyPlan>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t HookLauncher::PlanMemcpyDtoHParams::Reader::getSrcFakePtr() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t HookLauncher::PlanMemcpyDtoHParams::Builder::getSrcFakePtr() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void HookLauncher::PlanMemcpyDtoHParams::Builder::setSrcFakePtr( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t HookLauncher::PlanMemcpyDtoHParams::Reader::getSize() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t HookLauncher::PlanMemcpyDtoHParams::Builder::getSize() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void HookLauncher::PlanMemcpyDtoHParams::Builder::setSize( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool HookLauncher::PlanMemcpyDtoHResults::Reader::hasPlan() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool HookLauncher::PlanMemcpyDtoHResults::Builder::hasPlan() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::MemcpyPlan::Reader HookLauncher::PlanMemcpyDtoHResults::Reader::getPlan() const {
  return ::capnp::_::PointerHelpers< ::MemcpyPlan>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::MemcpyPlan::Builder HookLauncher::PlanMemcpyDtoHResults::Builder::getPlan() {
  return ::capnp::_::PointerHelpers< ::MemcpyPlan>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::MemcpyPlan::Pipeline HookLauncher::PlanMemcpyDtoHResults::Pipeline::getPlan() {
  return  ::MemcpyPlan::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void HookLauncher::PlanMemcpyDtoHResults::Builder::setPlan( ::MemcpyPlan::Reader value) {
  ::capnp::_::PointerHelpers< ::MemcpyPlan>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::MemcpyPlan::Builder HookLauncher::PlanMemcpyDtoHResults::Builder::initPlan() {
  return ::capnp::_::PointerHelpers< ::MemcpyPlan>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void HookLauncher::PlanMemcpyDtoHResults::Builder::adoptPlan(
    ::capnp::Orphan< ::MemcpyPlan>&& value) {
  ::capnp::_::PointerHelpers< ::MemcpyPlan>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::MemcpyPlan> HookLauncher::PlanMemcpyDtoHResults::Builder::disownPlan() {
  return ::capnp::_::PointerHelpers< ::MemcpyPlan>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool HookLauncher::LaunchKernelParams::Reader::hasFunc() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool HookLauncher::LaunchKernelParams::Builder::hasFunc() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader HookLauncher::LaunchKernelParams::Reader::getFunc() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder HookLauncher::LaunchKernelParams::Builder::getFunc() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void HookLauncher::LaunchKernelParams::Builder::setFunc( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder HookLauncher::LaunchKernelParams::Builder::initFunc(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void HookLauncher::LaunchKernelParams::Builder::adoptFunc(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> HookLauncher::LaunchKernelParams::Builder::disownFunc() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t HookLauncher::LaunchKernelParams::Reader::getGridDim() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t HookLauncher::LaunchKernelParams::Builder::getGridDim() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void HookLauncher::LaunchKernelParams::Builder::setGridDim( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t HookLauncher::LaunchKernelParams::Reader::getBlockDim() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t HookLauncher::LaunchKernelParams::Builder::getBlockDim() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void HookLauncher::LaunchKernelParams::Builder::setBlockDim( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t HookLauncher::LaunchKernelParams::Reader::getSharedMem() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t HookLauncher::LaunchKernelParams::Builder::getSharedMem() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void HookLauncher::LaunchKernelParams::Builder::setSharedMem( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool HookLauncher::LaunchKernelParams::Reader::hasParams() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool HookLauncher::LaunchKernelParams::Builder::hasParams() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader HookLauncher::LaunchKernelParams::Reader::getParams() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder HookLauncher::LaunchKernelParams::Builder::getParams() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void HookLauncher::LaunchKernelParams::Builder::setParams( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder HookLauncher::LaunchKernelParams::Builder::initParams(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void HookLauncher::LaunchKernelParams::Builder::adoptParams(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> HookLauncher::LaunchKernelParams::Builder::disownParams() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::ErrorCode HookLauncher::LaunchKernelResults::Reader::getError() const {
  return _reader.getDataField< ::ErrorCode>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::ErrorCode HookLauncher::LaunchKernelResults::Builder::getError() {
  return _builder.getDataField< ::ErrorCode>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void HookLauncher::LaunchKernelResults::Builder::setError( ::ErrorCode value) {
  _builder.setDataField< ::ErrorCode>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool HookLauncher::GetNodeStatusResults::Reader::hasNodes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool HookLauncher::GetNodeStatusResults::Builder::hasNodes() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>::Reader HookLauncher::GetNodeStatusResults::Reader::getNodes() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>::Builder HookLauncher::GetNodeStatusResults::Builder::getNodes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void HookLauncher::GetNodeStatusResults::Builder::setNodes( ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>::Builder HookLauncher::GetNodeStatusResults::Builder::initNodes(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void HookLauncher::GetNodeStatusResults::Builder::adoptNodes(
    ::capnp::Orphan< ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>> HookLauncher::GetNodeStatusResults::Builder::disownNodes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::NodeStatus,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}


CAPNP_END_HEADER

